= Post-Quantum Cryptography Document Signing with HashiCorp Vault

This example demonstrates how to build a secure document signing service using Apache Camel with Post-Quantum Cryptography (PQC) and HashiCorp Vault for key lifecycle management.

== Features

* **Quantum-Resistant Signatures** - Signs documents using DILITHIUM, a NIST-standardized Post-Quantum Cryptographic algorithm
* **HashiCorp Vault Integration** - Stores and manages PQC keys in HashiCorp Vault for enterprise-grade security
* **Key Lifecycle Management** - Automatic tracking of key usage, age, rotation, and expiration
* **Key Usage Tracking** - Demonstrates key expiration after a predefined number of usages (default: 10 signatures)
* **Automatic Key Rotation** - When a key expires, a new key is **automatically generated and rotated**
* **Key Metadata Tracking** - Real-time visibility into key status, usage count, age, and lifecycle events
* **REST API** - HTTP endpoints for signing, verifying documents, and managing keys
* **Scheduled Monitoring** - Periodic checks for key rotation needs based on age and usage thresholds
* **Multi-Key Support** - Deprecated keys are retained for signature verification of old documents

== Prerequisites

* JBang installed (https://www.jbang.dev)
* Docker installed for running HashiCorp Vault

== Running HashiCorp Vault

Run HashiCorp Vault using Docker:

[source,sh]
----
$ docker run -d \
  --name vault \
  -p 8201:8200 \
  -e VAULT_DEV_ROOT_TOKEN_ID=myroot \
  -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 \
  hashicorp/vault:latest
----

This will start HashiCorp Vault configured with:

* Root token: `myroot`
* Port: `8201` (mapped from container port 8200)
* Secrets engine: `secret` (KV v2)

Wait a few seconds for Vault to fully start before proceeding.

== Project Structure

The example consists of the following files:

[source,text]
----
pqc-document-signing/
├── pqc-document-signing.yaml      # YAML configuration (beans + routes)
├── application.properties          # Configuration file
└── README.adoc                    # This file
----

== Running the Example

After Vault is configured and running, start the Camel application:

[source,sh]
----
$ jbang -Dcamel.jbang.version=4.16.0-SNAPSHOT camel@apache/camel run pqc-document-signing.yaml
----

The application will:

1. Register BouncyCastle security providers (BC, BCPQC)
2. Connect to HashiCorp Vault
3. Generate a DILITHIUM Post-Quantum Cryptographic key pair
4. Store the key securely in Vault at path: `secret/data/pqc/keys/document-signing-key`
5. Start REST API endpoints on port 8080
6. Begin monitoring key lifecycle (usage count, age, rotation needs)

== API Endpoints

The application exposes the following REST endpoints:

=== 1. Sign a Document

Signs a document with a quantum-resistant signature.

[source,sh]
----
$ curl -X POST http://localhost:8080/api/sign \
  -H "Content-Type: text/plain" \
  -d "This is a confidential document that needs quantum-resistant protection"
----

**Response:**
[source,json]
----
{
  "status": "signed",
  "document": "This is a confidential document...",
  "signature": "UMyKJt21oIYWNq0jDe6v63Xw8bs7JZ9hg9KEYXdFPIMxXS3AHwOa...",
  "signatureAlgorithm": "DILITHIUM",
  "keyId": "document-signing-key",
  "keyMetadata": {
    "keyId": "document-signing-key",
    "algorithm": "DILITHIUM",
    "status": "ACTIVE",
    "usageCount": 1,
    "ageInDays": 0
  }
}
----

Note: The `signature` field contains a base64-encoded quantum-resistant signature.

=== 2. Verify a Document Signature

Verifies the authenticity of a signed document using the signature from the sign response.

[source,sh]
----
$ curl -X POST http://localhost:8080/api/verify \
  -H "Content-Type: text/plain" \
  -H "X-Signature: UMyKJt21oIYWNq0jDe6v63Xw8bs7JZ9hg9KEYXdFPIMxXS3AHwOa..." \
  -d "This is a confidential document that needs quantum-resistant protection"
----

Note: Pass the base64-encoded signature from the sign response in the `X-Signature` header. The `X-Signature` header is used instead of `CamelPQCSignature` to avoid header filtering by REST frameworks.

**Response:**
[source,json]
----
{
  "status": "verified",
  "valid": true,
  "message": "Document signature is valid",
  "signatureAlgorithm": "DILITHIUM"
}
----

=== 3. Get Key Metadata

Retrieves detailed metadata about the signing key, including usage count and lifecycle status.

[source,sh]
----
$ curl http://localhost:8080/api/key/metadata
----

**Response:**
[source,json]
----
{
  "keyId": "document-signing-key",
  "algorithm": "DILITHIUM",
  "status": "ACTIVE",
  "createdAt": "2024-10-13T10:30:00Z",
  "lastUsedAt": "2024-10-13T10:35:00Z",
  "usageCount": 5,
  "ageInDays": 0,
  "expiresAt": null,
  "nextRotationAt": null,
  "expired": false,
  "needsRotation": false
}
----

=== 4. List All Keys

Lists all PQC keys stored in Vault.

[source,sh]
----
$ curl http://localhost:8080/api/keys
----

**Response:**
[source,json]
----
{
  "keys": [
    {
      "keyId": "document-signing-key",
      "algorithm": "DILITHIUM",
      "status": "ACTIVE",
      "usageCount": 5
    }
  ]
}
----

=== 5. Rotate Signing Key

Manually rotates the signing key (creates a new key and deprecates the old one).

[source,sh]
----
$ curl -X POST http://localhost:8080/api/key/rotate
----

**Response:**
[source,json]
----
{
  "status": "rotated",
  "oldKey": "document-signing-key",
  "newKey": "document-signing-key",
  "message": "Key rotation completed successfully"
}
----

== Automatic Key Rotation

The example demonstrates automatic key rotation when keys reach expiration criteria:

* **Usage-based**: After 10 signatures (configurable via `key.max.usage.count`)
* **Age-based**: After 90 days (configurable via `key.max.age.days`)

When a key expires, the system automatically rotates to a new key, marking the old key as `DEPRECATED` for verification of previously signed documents.

**Test rotation:**
[source,sh]
----
# Sign document 10 times to trigger automatic rotation
$ for i in {1..10}; do
  curl -X POST http://localhost:8080/api/sign \
    -H "Content-Type: text/plain" \
    -d "Document number $i"
done

# View both old and new keys
$ curl http://localhost:8080/api/keys
----

== Key Storage in HashiCorp Vault

The PQC keys are stored in Vault's KV v2 secrets engine with the following structure:

[source,text]
----
secret/
└── data/
    └── pqc/
        └── keys/
            └── document-signing-key/
                ├── private/       # PKCS#8 private key
                ├── public/        # X.509 public key
                └── metadata/      # Key metadata
----

This separation enables fine-grained access control where applications can access public keys for verification without having access to private keys for signing.

== Configuration

Configuration is managed in `application.properties`:

[source,properties]
----
# Vault connection
vault.host=localhost
vault.port=8201
vault.token=myroot

# Key rotation policy
key.max.usage.count=10        # Max signatures before rotation
key.max.age.days=90            # Max key age in days
key.rotation.check.period=60000 # Check interval (ms)
----

== Troubleshooting

=== Connection to Vault Failed

* Ensure Vault is running: `docker ps`
* Verify the port in `application.properties` is set to `8201`
* Check the Vault token is correct (default: `myroot`)

=== Key Not Found in Vault

* Check Vault UI at http://localhost:8201 (token: `myroot`)
* Verify the secrets engine is enabled: `vault secrets list`
* Check the key path: `secret/data/pqc/keys/document-signing-key`

=== Signature Verification Failed

* Ensure you're using the same document content for both signing and verification
* Include the `X-Signature` header with the base64-encoded signature from the sign response
* The signature must be passed exactly as received from the sign endpoint (base64 string)
* Verify the key hasn't been rotated or revoked
* Check logs for "ERROR during verification" messages which indicate signature format issues

== Stopping

To stop the Camel application, press `Ctrl+C`.

To stop HashiCorp Vault:

[source,sh]
----
$ docker stop vault
$ docker rm vault
----

== Implementation Details

The `pqc-document-signing.yaml` file contains:

=== Bean Configuration

**1. Security Initialization Bean** - Registers BouncyCastle providers at startup:

[source,yaml]
----
- beans:
  - name: initSecurity
    type: java.lang.Object
    scriptLanguage: groovy
    script: |
      // Register BouncyCastle providers
      if (java.security.Security.getProvider("BC") == null) {
          java.security.Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider())
      }
      if (java.security.Security.getProvider("BCPQC") == null) {
          java.security.Security.addProvider(new org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider())
      }
      return new Object()
----

**2. HashicorpVaultKeyLifecycleManager** - Created using Groovy script with 6-parameter constructor:

[source,yaml]
----
  - name: keyLifecycleManager
    type: org.apache.camel.component.pqc.lifecycle.HashicorpVaultKeyLifecycleManager
    scriptLanguage: groovy
    script: |
      new org.apache.camel.component.pqc.lifecycle.HashicorpVaultKeyLifecycleManager(
          '{{vault.host}}',           // Vault server hostname
          {{vault.port}},             // Vault server port
          '{{vault.scheme}}',         // Connection scheme (http/https)
          '{{vault.token}}',          // Vault authentication token
          '{{vault.secrets.engine}}', // KV secrets engine name
          '{{vault.keys.prefix}}'     // Prefix for key paths in Vault
      )
----

=== Route Definitions

The YAML file defines 12 routes using Camel YAML DSL:

1. **initialize-signing-key** - Generates DILITHIUM key pair and registers it as a bean
2. **sign-document-api** - POST `/api/sign` - Signs documents with PQC signature
3. **verify-document-api** - POST `/api/verify` - Verifies document signatures (uses `X-Signature` header)
4. **get-key-metadata-api** - GET `/api/key/metadata` - Returns key metadata
5. **list-keys-api** - GET `/api/keys` - Lists all PQC keys in Vault
6. **rotate-key-api** - POST `/api/key/rotate` - Manual key rotation
7. **check-rotation-schedule** - Timer-based rotation checks
8. **update-key-usage** - Helper route for updating key usage metadata
9. **get-key-metadata-helper** - Helper route for retrieving key metadata
10. **check-key-expiration** - Helper route checking if key expired
11. **auto-rotate-key** - Automatic key rotation when key expires

=== Key Features

- **Declarative Configuration** - All beans and routes defined in YAML
- **Groovy Scripts** - Used for bean instantiation and signature conversion
- **Property Placeholders** - All configuration values from `application.properties`
- **No Compilation Required** - Routes can be modified without recompilation

== Security Notice

This example uses **development settings**. For production:

* Use HTTPS for Vault (`vault.scheme=https`)
* Use AppRole or similar authentication instead of root tokens
* Configure Vault access policies
* Increase `key.max.usage.count` to realistic values (e.g., 100,000)
* Enable Vault audit logging

== Help and Contributions

If you hit any problem using Camel or have some feedback, then please
https://camel.apache.org/community/support/[let us know].

We also love contributors, so
https://camel.apache.org/community/contributing/[get involved] :-)

The Camel riders!
